/**
 * Shader chunks for WebLG Shader library
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author bhouston / http://clara.io/
 */

THREE.ShaderChunk = {

	// FOG

	common: [

		"#define PI 3.14159",
		"#define PI2 6.28318",
		"#define LOG2 1.442695",
		"float square( in float a ) { return a*a; }",
		"vec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }",
		"vec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }",
		"vec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }",
		"float saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }",
		"vec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }",
		"vec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }",
		"vec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }",
		"float average( in float a ) { return a; }",
		"float average( in vec2 a )  { return ( a.x + a.y) * 0.5; }",
		"float average( in vec3 a )  { return ( a.x + a.y + a.z) * 0.3333333333; }",
		"float average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }",
		"float whiteCompliment( in float a ) { return saturate( 1.0 - a ); }",
		"vec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }",
		"vec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }",
		"vec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }",
		"vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {",
    		"float distance = dot( planeNormal, point-pointOnPlane );",
    		"return point - distance * planeNormal;",
		"}",
		"float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {",
   			"return sign( dot( point - pointOnPlane, planeNormal ) );",
		"}",
		"vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {",
   			"return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );",
		"}",
		"vec4 texelDecode( vec4 texel, int encoding ) {",

			"if( encoding == 3001 ) {",	// gamma.
				"texel = vec4( square( texel.xyz ), texel.w );",
			"}",

			"else if( encoding == 3002 ) {",	// RGBE (Radiance)
				"texel = vec4( texel.xyz * pow( 2.0, texel.w*256.0 - 128.0 ), 1.0 );",
			"}",

			// TODO LogLUV decoding.

			"else if( encoding == 3004 ) {", // Scale 7.0 (Marmoset)
				"texel = vec4( texel.xyz * texel.w * 7.0, 1.0 );",
			"}",


			"else if( encoding == 3005 ) {", // Scale 16
				"texel = vec4( texel.xyz * texel.w * 16.0, 1.0 );",
			"}",

			"if( encoding == 0 ) {",

				"#ifdef GAMMA_INPUT",

					"texel.xyz *= texel.xyz;",

				"#endif",

			"}",

			"return texel;",
		"}",
	].join("\n"),

	// FOG

	fog_pars_fragment: [

		"#ifdef USE_FOG",

			"uniform vec3 fogColor;",

			"#ifdef FOG_EXP2",

				"uniform float fogDensity;",

			"#else",

				"uniform float fogNear;",
				"uniform float fogFar;",

			"#endif",

		"#endif"

	].join("\n"),

	fog_fragment: [

		"#ifdef USE_FOG",

			"float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"#ifdef FOG_EXP2",

				"float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );",
				"fogFactor = 1.0 - saturate( fogFactor );",

			"#else",

				"float fogFactor = smoothstep( fogNear, fogFar, depth );",

			"#endif",

			"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

		"#endif"

	].join("\n"),

	// DIFFUSE ENVIRONMENT MAP

	diffuseenvmap_pars_fragment: [

		"#if defined( USE_DIFFUSEENVMAP )",

			"uniform samplerCube diffuseEnvMap;",
			"uniform int diffuseEnvEncoding;",

		"#endif"

	].join("\n"),

	// ENVIRONMENT MAP

	envmap_pars_fragment: [

		"#if defined( USE_ENVMAP )",

			"uniform float reflectivity;",

		"#endif",

		"#if defined( USE_DIFFUSEENVMAP ) || defined( USE_ENVMAP )",

			"uniform float flipEnvMap;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"uniform bool useRefract;",
				"uniform float refractionRatio;",

			"#else",

				"varying vec3 vReflect;",

			"#endif",

		"#endif",

		"#ifdef USE_ENVMAP",

			"uniform samplerCube envMap;",
			"uniform int combine;",
			"uniform int envEncoding;",

		"#endif"

	].join("\n"),

	envmap_fragment: [

		"#if defined( USE_ENVMAP ) && ! defined( PHYSICAL )",

			"vec3 reflectVec = vReflect;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"vec3 worldNormal = vec3( normalize( ( vec4( normal, 0.0 ) * viewMatrix ).xyz ) );",
				"vec3 worldView = -vec3( normalize( ( vec4( viewPosition, 0.0 ) * viewMatrix ).xyz ) );",

				"if ( useRefract ) {",

					// viewPosition may inverted
					"reflectVec = refract( worldView, worldNormal, refractionRatio );",

				"} else { ",

					"reflectVec = reflect( worldView, worldNormal );",

				"}",

				"#else",

			"#endif",

			"#ifdef DOUBLE_SIDED",

				"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );",

				"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#else",

				"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#endif",

			"cubeColor = texelDecode( cubeColor, envEncoding );",

			"if( envEncoding == 0 ) {",

				"#ifdef GAMMA_INPUT",

					"cubeColor.xyz *= cubeColor.xyz;",

				"#endif",

			"}",

			"float fresnelReflectivity = saturate( reflectivity );",

			"if ( combine == 1 ) {",

				"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, fresnelReflectivity );",

			"} else if ( combine == 2 ) {",

				"gl_FragColor.xyz += cubeColor.xyz * fresnelReflectivity;",

			"} else {",

				"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, fresnelReflectivity );",

			"}",

		"#endif"

	].join("\n"),

	envmap_pars_vertex: [

		"#if ( defined( USE_ENVMAP ) || defined( USE_DIFFUSEENVMAP ) ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"varying vec3 vReflect;",

			"uniform float refractionRatio;",
			"uniform bool useRefract;",

		"#endif"

	].join("\n"),

	worldpos_vertex : [

		"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",

			"#ifdef USE_SKINNING",

				"vec4 worldPosition = modelMatrix * skinned;",

			"#endif",

			"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );",

			"#endif",

			"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_vertex : [

		"#if ( defined( USE_ENVMAP ) || defined( USE_DIFFUSEENVMAP ) ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;",
			"worldNormal = normalize( worldNormal );",

			"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",

			"if ( useRefract ) {",

				"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",

			"} else {",

				"vReflect = reflect( cameraToVertex, worldNormal );",

			"}",

		"#endif"

	].join("\n"),

	// COLOR MAP (particles)

	map_particle_pars_fragment: [

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),


	map_particle_fragment: [

		"#ifdef USE_MAP",

			"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );",

		"#endif"

	].join("\n"),

	// COLOR MAP (triangles)

	map_pars_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )",

			"varying vec2 vUv;",
//			"uniform vec4 offsetRepeat;",

		"#endif"

	].join("\n"),

	map_pars_fragment: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )",

			"varying vec2 vUv;",
			"uniform vec4 offsetRepeat;",
			"uniform vec4 gainBrightness;",

			"vec4 applyGainBrightness( vec4 texel, vec4 gainBrightnessCoeff ) {",

				"texel.xyz = ( texel.xyz - vec3( gainBrightnessCoeff.x ) ) * gainBrightnessCoeff.y + vec3( gainBrightnessCoeff.z + gainBrightnessCoeff.x );",

				"return texel;",

			"}",

		"#endif",

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),

	map_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )",

			"vUv = uv;",

		"#endif"

	].join("\n"),

	map_fragment: [

		"#if defined( USE_MAP ) || defined( USE_FALLOFFMAP )",

			"vec2 vUvLocal = vUv * offsetRepeat.zw + offsetRepeat.xy;",

		"#endif",

		"#ifdef USE_MAP",

			"vec4 texelColor = applyGainBrightness( texture2D( map, vUvLocal ), gainBrightness );",

			"#ifdef GAMMA_INPUT",

				"texelColor.xyz *= texelColor.xyz;",

			"#endif",

			"gl_FragColor = gl_FragColor * texelColor;",

			"#if defined( PHYSICAL ) || defined( PHONG )",

				"diffuseColor *= texelColor.xyz;",

			"#endif", // PHYSICAL

		"#endif"

	].join("\n"),

	// FALLOFF MAP

	falloffmap_pars_fragment: [

		"#ifdef USE_FALLOFFMAP",

			"uniform sampler2D falloffMap;",

		"#endif"

	].join("\n"),

	// OPACITY MAP

	opacitymap_pars_vertex: [

		"#ifdef USE_OPACITYMAP",

//			"varying vec2 vOpacityUv;",
//			"uniform vec4 opacityOffsetRepeat;",

		"#endif"

	].join("\n"),

	opacitymap_vertex: [

		"#ifdef USE_OPACITYMAP",

//			"vOpacityUv = uv * opacityOffsetRepeat.zw + opacityOffsetRepeat.xy;",

		"#endif"

	].join("\n"),

	opacitymap_pars_fragment: [

		"#ifdef USE_OPACITYMAP",

			"uniform sampler2D opacityMap;",
//			"varying vec2 vOpacityUv;",
			"uniform vec4 opacityOffsetRepeat;",
			"uniform vec4 opacityGainBrightness;",

		"#endif"

	].join("\n"),


	opacitymap_fragment: [

		"#ifdef USE_OPACITYMAP",

			"vec2 vOpacityUv = vUv * opacityOffsetRepeat.zw + opacityOffsetRepeat.xy;",
			"vec4 texelOpacity = applyGainBrightness( texture2D( opacityMap, vOpacityUv ), opacityGainBrightness );",

			"gl_FragColor.w = gl_FragColor.w * texelOpacity.r;",

		"#endif"

	].join("\n"),

	// TRANSLUCENCY MAP

	translucencymap_pars_vertex: [

		"#ifdef USE_TRANSLUCENCYMAP",

//			"varying vec2 vTranslucencyUv;",
//			"uniform vec4 translucencyOffsetRepeat;",

		"#endif"

	].join("\n"),

	translucencymap_vertex: [

		"#ifdef USE_TRANSLUCENCYMAP",

//			"vTranslucencyUv = uv * translucencyOffsetRepeat.zw + translucencyOffsetRepeat.xy;",

		"#endif"

	].join("\n"),

	translucencymap_pars_fragment: [

		"#ifdef USE_TRANSLUCENCYMAP",

			"uniform sampler2D translucencyMap;",
//			"varying vec2 vTranslucencyUv;",
			"uniform vec4 translucencyOffsetRepeat;",
			"uniform vec4 translucencyGainBrightness;",

		"#endif"

	].join("\n"),

	translucencymap_fragment: [

		"#ifdef USE_TRANSLUCENCYMAP",

			"vec2 vTranslucencyUv = vUv * translucencyOffsetRepeat.zw + translucencyOffsetRepeat.xy;",
			"vec4 texelTranslucency = applyGainBrightness( texture2D( translucencyMap, vTranslucencyUv ), translucencyGainBrightness );",

			"#ifdef GAMMA_INPUT",

				"texelTranslucency.xyz *= texelTranslucency.xyz;",

			"#endif",

			"translucencyColor.xyz *= texelTranslucency.xyz;",

		"#endif"

	].join("\n"),

	// LIGHT MAP

	lightmap_pars_fragment: [

		"#if defined( USE_LIGHTMAP ) || defined( USE_EMISSIVEMAP )",

			"varying vec2 vUv2;",

		"#endif",

		"#if defined( USE_LIGHTMAP )",

			"uniform sampler2D lightMap;",

		"#endif",

		"#if defined( USE_EMISSIVEMAP )",

			"uniform sampler2D emissiveMap;",

		"#endif"

	].join("\n"),

	lightmap_pars_vertex: [

		"#if defined( USE_LIGHTMAP ) || defined( USE_EMISSIVEMAP )",

			"varying vec2 vUv2;",

		"#endif"

	].join("\n"),

	lightmap_fragment: [

		"#ifdef USE_LIGHTMAP",

			//"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );",

		"#endif"

	].join("\n"),

	lightmap_vertex: [

		"#if defined( USE_LIGHTMAP ) || defined( USE_EMISSIVEMAP )",

			"vUv2 = uv2;",

		"#endif"

	].join("\n"),


	// BUMP MAP

	bumpmap_pars_vertex: [

		"#ifdef USE_BUMPMAP",

//			"varying vec2 vBumpUv;",
//			"uniform vec4 bumpOffsetRepeat;",

		"#endif"

	].join("\n"),

	bumpmap_vertex: [

		"#ifdef USE_BUMPMAP",

//			"vBumpUv = uv * bumpOffsetRepeat.zw + bumpOffsetRepeat.xy;",

		"#endif"

	].join("\n"),

	bumpmap_pars_fragment: [

		"#ifdef USE_BUMPMAP",

			"uniform sampler2D bumpMap;",
			"uniform vec4 bumpOffsetRepeat;",
			"uniform float bumpScale;",

			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen
			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html

			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

			"vec2 dHdxy_fwd() {",

				"vec2 vBumpUv = vUv * bumpOffsetRepeat.zw + bumpOffsetRepeat.xy;",

				"vec2 dSTdx = dFdx( vBumpUv );",
				"vec2 dSTdy = dFdy( vBumpUv );",

				"float Hll = bumpScale * texture2D( bumpMap, vBumpUv ).x;",
				"float dBx = bumpScale * texture2D( bumpMap, vBumpUv + dSTdx ).x - Hll;",
				"float dBy = bumpScale * texture2D( bumpMap, vBumpUv + dSTdy ).x - Hll;",

				"return vec2( dBx, dBy );",

			"}",

			"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",

				"vec3 vSigmaX = dFdx( surf_pos );",
				"vec3 vSigmaY = dFdy( surf_pos );",
				"vec3 vN = surf_norm;",		// normalized

				"vec3 R1 = cross( vSigmaY, vN );",
				"vec3 R2 = cross( vN, vSigmaX );",

				"float fDet = dot( vSigmaX, R1 );",

				"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
				"return normalize( abs( fDet ) * surf_norm - vGrad );",

			"}",

		"#endif"

	].join("\n"),

	// LIGHT ATTENUATION function

	lightattenuation_func_fragment: [

		"float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {",
			"float distanceAttenuation = 1.0 / pow( lightDistance, decayExponent );",
			"if ( cutoffDistance > 0.0 ) {",
				"distanceAttenuation *= 1.0 - min( lightDistance / cutoffDistance, 1.0 );",
			"}",
			"return distanceAttenuation;",
		"}"

	].join("\n"),

	// NORMAL MAP

	normalmap_pars_vertex: [

		"#ifdef USE_NORMALMAP",

//			"varying vec2 vNormalUv;",
//			"uniform vec4 normalOffsetRepeat;",

		"#endif"

	].join("\n"),

	normalmap_vertex: [

		"#ifdef USE_NORMALMAP",

//			"vNormalUv = uv * normalOffsetRepeat.zw + normalOffsetRepeat.xy;",

		"#endif"

	].join("\n"),

	normalmap_pars_fragment: [

		"#ifdef USE_NORMALMAP",

			"uniform sampler2D normalMap;",
//			"varying vec2 vNormalUv;",
			"uniform vec4 normalOffsetRepeat;",
			"uniform vec2 normalScale;",

			// Per-Pixel Tangent Space Normal Mapping
			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

			"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",

				"vec2 vNormalUv = vUv * normalOffsetRepeat.zw + normalOffsetRepeat.xy;",

				"vec3 q0 = dFdx( eye_pos.xyz );",
				"vec3 q1 = dFdy( eye_pos.xyz );",
				"vec2 st0 = dFdx( vNormalUv.st );",
				"vec2 st1 = dFdy( vNormalUv.st );",

				"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
				"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
				"vec3 N = normalize( surf_norm );",

				"vec3 mapN = texture2D( normalMap, vNormalUv ).xyz * 2.0 - 1.0;",
				"mapN.xy = normalScale * mapN.xy;",
				"mat3 tsn = mat3( S, T, N );",
				"return normalize( tsn * mapN );",

			"}",

		"#endif"

	].join("\n"),

	// ANISOTROPY MAP

	anisotropymap_pars_vertex: [

		"#ifdef USE_ANISOTROPYMAP",

//			"varying vec2 vAnisotropyUv;",
//			"uniform vec4 anisotropyOffsetRepeat;",

		"#else",

			"#ifdef ANISOTROPY",

//				"varying vec2 vAnisotropyUv;",

			"#endif",

		"#endif"
	].join("\n"),

	anisotropymap_vertex: [

/*		"#ifdef USE_ANISOTROPYMAP",

			"vAnisotropyUv = uv * anisotropyOffsetRepeat.zw + anisotropyOffsetRepeat.xy;",

		"#else",

			"#ifdef ANISOTROPY",

				"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )",

					"vAnisotropyUv = vUv;",

				"#else",

					"vAnisotropyUv = vec2( 0, 0 );",

				"#endif",

			"#endif",

		"#endif"*/

	].join("\n"),


	anisotropymap_pars_fragment: [

		"#ifdef USE_ANISOTROPYMAP",

			"uniform sampler2D anisotropyMap;",
			"uniform vec4 anisotropyGainBrightness;",
			"uniform vec4 anisotropyOffsetRepeat;",
			//"varying vec2 vAnisotropyUv;",

		"#else",

			"#ifdef ANISOTROPY",

				//"varying vec2 vAnisotropyUv;",

			"#endif",

		"#endif"
	].join("\n"),

	anisotropymap_fragment: [

		"#ifdef USE_ANISOTROPYMAP",

			"vec2 vAnisotropyUv = vUv * anisotropyOffsetRepeat.zw + anisotropyOffsetRepeat.xy;",

		"#else",

			"#ifdef ANISOTROPY",

				"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )",

					"vec2 vAnisotropyUv = vUv;",

				"#else",

					"vec2 vAnisotropyUv = vec2( 0, 0 );",

				"#endif",

			"#endif",

		"#endif",

		"float anisotropyStrength = anisotropy;",

		"#ifdef USE_ANISOTROPYMAP",

			"vec4 texelAnisotropy = applyGainBrightness( texture2D( anisotropyMap, vAnisotropyUv ), anisotropyGainBrightness );",
			"anisotropyStrength += texelAnisotropy.r;",

		"#endif"

	].join("\n"),

	// ANISOTROPY ROTATION MAP

	anisotropyrotationmap_pars_vertex: [

		"#ifdef USE_ANISOTROPYROTATIONMAP",

//			"varying vec2 vAnisotropyRotationUv;",
//			"uniform vec4 anisotropyRotationOffsetRepeat;",

		"#endif"

	].join("\n"),

	anisotropyrotationmap_vertex: [

		"#ifdef USE_ANISOTROPYROTATIONMAP",

//			"vAnisotropyRotationUv = uv * anisotropyRotationOffsetRepeat.zw + anisotropyRotationOffsetRepeat.xy;",

		"#endif"

	].join("\n"),


	anisotropyrotationmap_pars_fragment: [

		"#ifdef USE_ANISOTROPYROTATIONMAP",

			"uniform sampler2D anisotropyRotationMap;",
			"uniform vec4 anisotropyRotationGainBrightness;",
			"uniform vec4 anisotropyRotationOffsetRepeat;",
//			"varying vec2 vAnisotropyRotationUv;",

		"#endif"

	].join("\n"),

	anisotropyrotationmap_fragment: [

		"float anisotropyRotationStrength = anisotropyRotation;",

		"#ifdef USE_ANISOTROPYROTATIONMAP",

			"vec2 vAnisotropyRotationUv = vUv * anisotropyRotationOffsetRepeat.zw + anisotropyRotationOffsetRepeat.xy;",
			"vec4 texelAnisotropyRotation = applyGainBrightness( texture2D( anisotropyRotationMap, vAnisotropyRotationUv ), anisotropyRotationGainBrightness );",
			"anisotropyRotationStrength += texelAnisotropyRotation.r;",

		"#endif"

	].join("\n"),

	// METALLIC MAP

	metallicmap_pars_vertex: [

		"#ifdef USE_METALLICMAP",

//			"varying vec2 vMetallicUv;",
//			"uniform vec4 metallicOffsetRepeat;",

		"#endif"

	].join("\n"),

	metallicmap_vertex: [

		"#ifdef USE_METALLICMAP",

//			"vMetallicUv = uv * metallicOffsetRepeat.zw + metallicOffsetRepeat.xy;",

		"#endif"

	].join("\n"),


	metallicmap_pars_fragment: [

		"#ifdef USE_METALLICMAP",

			"uniform sampler2D metallicMap;",
			"uniform vec4 metallicGainBrightness;",
			"uniform vec4 metallicOffsetRepeat;",

		"#endif"

	].join("\n"),

	metallicmap_fragment: [

		"float metallicStrength = metallic;",

		"#ifdef USE_METALLICMAP",

			"vec2 vMetallicUv = vUv * metallicOffsetRepeat.zw + metallicOffsetRepeat.xy;",
			"vec4 texelMetallic = applyGainBrightness( texture2D( metallicMap, vMetallicUv ), metallicGainBrightness );",
			"metallicStrength *= texelMetallic.r;",

		"#endif"

	].join("\n"),

	// ROUGHNESS MAP

	roughnessmap_pars_vertex: [

		"#ifdef USE_ROUGHNESSMAP",

//			"varying vec2 vRoughnessUv;",
//			"uniform vec4 roughnessOffsetRepeat;",

		"#endif"

	].join("\n"),

	roughnessmap_vertex: [

		"#ifdef USE_ROUGHNESSMAP",

//			"vRoughnessUv = uv * roughnessOffsetRepeat.zw + roughnessOffsetRepeat.xy;",

		"#endif"

	].join("\n"),


	roughnessmap_pars_fragment: [

		"#ifdef USE_ROUGHNESSMAP",

			"uniform sampler2D roughnessMap;",
			"uniform vec4 roughnessOffsetRepeat;",
			"uniform vec4 roughnessGainBrightness;",

		"#endif"

	].join("\n"),

	roughnessmap_fragment: [

		"float roughnessStrength = roughness;",

		"#ifdef USE_ROUGHNESSMAP",

			"vec2 vRoughnessUv = vUv * roughnessOffsetRepeat.zw + roughnessOffsetRepeat.xy;",
			"vec4 texelRoughness = applyGainBrightness( texture2D( roughnessMap, vRoughnessUv ), roughnessGainBrightness );",
			"roughnessStrength *= texelRoughness.r;",

		"#endif"

	].join("\n"),

	// SPECULAR MAP

	specularmap_pars_vertex: [

		"#ifdef USE_SPECULARMAP",

//			"varying vec2 vSpecularUv;",
//			"uniform vec4 specularOffsetRepeat;",

		"#endif"

	].join("\n"),

	specularmap_vertex: [

		"#ifdef USE_SPECULARMAP",

			//"vSpecularUv = uv * specularOffsetRepeat.zw + specularOffsetRepeat.xy;",

		"#endif"

	].join("\n"),

	specularmap_pars_fragment: [

		"#ifdef USE_SPECULARMAP",

			"uniform sampler2D specularMap;",
			"uniform vec4 specularGainBrightness;",
			"uniform vec4 specularOffsetRepeat;",

		"#endif"

	].join("\n"),

	specularmap_fragment: [

		"float specularStrength;",

		"#ifdef USE_SPECULARMAP",

			"vec2 vSpecularUv = vUv * specularOffsetRepeat.zw + specularOffsetRepeat.xy;",
			"vec4 texelSpecular = applyGainBrightness( texture2D( specularMap, vSpecularUv ), specularGainBrightness );",
			"specularStrength = texelSpecular.r;",

		"#else",

			"specularStrength = 1.0;",

		"#endif"

	].join("\n"),

	// LIGHTS LAMBERT

	lights_lambert_pars_vertex: [

		"uniform vec3 ambient;",
		"uniform vec3 diffuse;",
		"uniform vec3 emissive;",

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDecayExponent[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDecayExponent[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"uniform vec3 areaLightColor[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightPosition[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightWidth[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightHeight[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDistance[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDecayExponent[ MAX_AREA_LIGHTS ];",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif"

	].join("\n"),

	lights_lambert_vertex: [

		"vLightFront = vec3( 0.0 );",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = vec3( 0.0 );",

		"#endif",

		"transformedNormal = normalize( transformedNormal );",

		"#if MAX_DIR_LIGHTS > 0",

		"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

			"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
			"vec3 dirVector = normalize( lDirection.xyz );",

			"float dotProduct = dot( transformedNormal, dirVector );",
			"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",

			"#ifdef DOUBLE_SIDED",

				"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

				"#ifdef WRAP_AROUND",

					"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

				"#endif",

			"#endif",

			"#ifdef WRAP_AROUND",

				"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
				"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );",

				"#ifdef DOUBLE_SIDED",

					"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );",

				"#endif",

			"#endif",

			"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;",

			"#ifdef DOUBLE_SIDED",

				"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;",

			"#endif",

		"}",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float distanceAttenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecayExponent[i] );",

				"lVector = normalize( lVector );",
				"float dotProduct = dot( transformedNormal, lVector );",

				"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );",

				"#ifdef DOUBLE_SIDED",

					"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

					"#ifdef WRAP_AROUND",

						"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

					"#endif",

				"#endif",

				"#ifdef WRAP_AROUND",

					"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
					"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );",

					"#ifdef DOUBLE_SIDED",

						"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );",

					"#endif",

				"#endif",

				"vLightFront += pointLightColor[ i ] * pointLightWeighting * distanceAttenuation;",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * distanceAttenuation;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float distanceAttenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecayExponent[i] );",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					"lVector = normalize( lVector );",

					"float dotProduct = dot( transformedNormal, lVector );",
					"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );",

					"#ifdef DOUBLE_SIDED",

						"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

						"#ifdef WRAP_AROUND",

							"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

						"#endif",

					"#endif",

					"#ifdef WRAP_AROUND",

						"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
						"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );",

						"#ifdef DOUBLE_SIDED",

							"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );",

						"#endif",

					"#endif",

					"vLightFront += spotLightColor[ i ] * spotLightWeighting * distanceAttenuation * spotEffect;",

					"#ifdef DOUBLE_SIDED",

						"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * distanceAttenuation * spotEffect;",

					"#endif",

				"}",

			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				"float dotProduct = dot( transformedNormal, lVector );",

				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
				"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;",

				"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );",

				"#endif",

			"}",

		"#endif",

		"vLightFront = ( vLightFront + ambientLightColor + ambient) * diffuse + emissive;",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = ( vLightFront + ambientLightColor + ambient) * diffuse + emissive;",

		"#endif"

	].join("\n"),

	// LIGHTS PHYSICAL

	lights_physical_pars_vertex: [

		"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )",

			"varying vec3 vWorldPosition;",

		"#endif"

	].join("\n"),


	lights_physical_vertex: [

		"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )",

			"vWorldPosition = worldPosition.xyz;",

		"#endif",

		"#ifdef USE_SKINNING",

			"vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

			"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
			"vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

		"#else",

			"vNormal = normalize( normalMatrix * normal );",
			"vTangent = normalize( normalMatrix * tangent.xyz );",

		"#endif",

		"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",


	].join("\n"),

	lights_physical_pars_fragment: [

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDecayExponent[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDecayExponent[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"uniform vec3 areaLightColor[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightPosition[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightWidth[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightHeight[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDistance[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDecayExponent[ MAX_AREA_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif",

		"varying vec3 vViewPosition;",
		"varying vec3 vTangent;",
		"varying vec3 vBinormal;",
		"varying vec3 vNormal;",

		// classic Fresnel Schlick
		/*"float Fresnel_Schlick( float hDotV ) {",
			"float F0 = 0.04;",
			"return F0 + ( 1.0 - F0 ) * pow( 1.0 - hDotV, 5.0 );",
		"}",*/

		// Calcuate the Fresnel term using the Schlick approximation (using Unreal's blend to white method)  VALIDATED
		"vec3 Fresnel_Schlick_SpecularBlendToWhite(vec3 specularColor, float hDotV) {",
			"float Fc = pow(1.0 - hDotV, 5.0);",
    		"return saturate( 50.0 * average( specularColor ) ) * Fc + (1.0 - Fc) * specularColor;",
		"}",

		"vec3 Fresnel_Schlick_SpecularBlendToWhiteRoughness(vec3 specularColor, float hDotV, float roughness) {",
			"float Fc = pow(1.0 - hDotV, 5.0) / ( 1.0 + 3.0 * roughness );",

    		"return saturate( 50.0 * average( specularColor ) ) * Fc + (1.0 - Fc) * specularColor;",
		"}",

	    // Calculate the distribution term  VALIDATED
		"float Distribution_GGX( float roughness2, float nDotH ) {",
			"float denom = nDotH * nDotH * (roughness2 - 1.0) + 1.0;",
    		"return roughness2 / ( PI * square( denom ) + 0.0000001 );",
		"}",

		// Calculated the anisotropic GGZ distrubtion term     VALIDATED
		"float Distribution_GGXAniso( vec2 anisotropicM, vec2 xyDotH, float nDotH ) {",
    		"float anisoTerm = ( xyDotH.x * xyDotH.x / ( anisotropicM.x * anisotropicM.x ) + xyDotH.y * xyDotH.y / ( anisotropicM.y * anisotropicM.y ) + nDotH * nDotH );",
    		"return 1.0 / ( PI * anisotropicM.x * anisotropicM.y * anisoTerm * anisoTerm + 0.0000001 );",
		"}",

		// useful for clear coat surfaces, use with Distribution_GGX.
		"float Visibility_Kelemen( float vDotH ) {",
			"return 1.0 / ( 4.0 * vDotH * vDotH + 0.0000001 );",
		"}",

		"float Visibility_Schlick(in float roughness2, in float nDotL, in float nDotV) {",
    		"float termL = (nDotL + sqrt(roughness2 + (1.0 - roughness2) * nDotL * nDotL));",
    		"float termV = (nDotV + sqrt(roughness2 + (1.0 - roughness2) * nDotV * nDotV));",
    		"return 1.0 / ( abs( termL * termV ) + 0.0000001 );",
		"}",

		"float Diffuse_Lambert() {",
    		"return 1.0 / PI;",
		"}",

		"float Diffuse_OrenNayer(in float m2, in float nDotV, in float nDotL, in float vDotH ) {",
			"float termA = 1.0 - 0.5 * m2 / (m2 + 0.33);",
			"float Cosri = 2.0 * vDotH - 1.0 - nDotV * nDotL;",
			"float termB = 0.45 * m2 / (m2 + 0.09) * Cosri * ( Cosri >= 0.0 ? min( 1.0, nDotL / nDotV ) : nDotL );",
			"return 1.0 / PI * ( nDotL * termA + termB );",
		"}",

		// Helper for anisotropy rotation
		"mat2 createRotationMat2(in float rads) {",
			"float cos_rads = cos( rads );",
			"float sin_rads = sin( rads );",
    		"return mat2( vec2( cos_rads, sin_rads ), vec2( -sin_rads, cos_rads ) );",
		"}",

		// Helper for anisotropy rotation
		"vec2 calcAnisotropyUV(in float anisotropyLocal) {",
			"float oneMinusAbsAnisotropy = 1.0 - min( abs( anisotropyLocal ) * 0.9, 0.9 );",
			"vec2 anisotropyUV = vec2 ( 1.0 / oneMinusAbsAnisotropy, oneMinusAbsAnisotropy );",
			"if( anisotropy < 0.0 ) {",
				"anisotropyUV.xy = anisotropyUV.yx;", // swizzel
			"}",
    		"return anisotropyUV;",
		"}"

		//"float horizonOcclusion( vec3 reflectionVector, vec3 originalNormal ) {",
		//	"return quare( saturate( 1.0 + uHorizonOcclude*dot( dir, vertexNormal ) ) );",
		//"}"


	].join("\n"),

	lights_physical_fragment: [

		"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normal );",

		"#ifdef USE_NORMALMAP",

			"normal = perturbNormal2Arb( -vViewPosition, normal );",

			/*"vec3 normalTex = texture2D( normalMap, vNormalUv ).xyz * 2.0 - 1.0;",
			"normalTex.xy *= normalScale;",
			"normalTex = perturbNormal2Arb( -ViewPosition, normal );",

			"normal = tsb * normalTex;",*/

		//"vec3 originalNormal = normal;",
		"#endif",

		"#if defined( USE_BUMPMAP )",

			"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",

		"#endif",

		"#ifdef DOUBLE_SIDED",

			"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",

		"#endif",

		"#ifdef FALLOFF",

			"vec3 modulatedFalloffColor = falloffColor;",

			"#ifdef USE_FALLOFFMAP",

				"vec4 falloffTexelColor = texture2D( falloffMap, vUvLocal );",

				"#ifdef GAMMA_INPUT",

					"falloffTexelColor.xyz *= falloffTexelColor.xyz;",

				"#endif",

				"modulatedFalloffColor = modulatedFalloffColor * falloffTexelColor.xyz;",

			"#endif",

			"float fm = abs( dot( normal, viewPosition ) );",

			// this is a hack, it needs to be fixed.
			"fm = /*falloffBlendParams.x * fm + falloffBlendParams.y * */ ( fm * fm * ( 3.0 - 2.0 * fm ) );",

			"diffuseColor = mix( modulatedFalloffColor, diffuseColor, fm );",

		"#endif",

		"float nDotV = saturate( dot( normal, viewPosition ) );",
		"float m2 = pow( clamp( roughnessStrength, 0.02, 1.0 ), 4.0 );",
		// specular is scaled by 0.08 per Disney PBR recommendations.
		"float m2ClearCoat = pow( clamp( clearCoatRoughness, 0.02, 1.0 ), 4.0 );",

		"vec3 specularColor = mix( specular * 0.18, diffuseColor, metallicStrength );",
		"diffuseColor *= ( 1.0 - metallicStrength );",

		"#ifdef ANISOTROPY",

			"vec2 anisotropicM = calcAnisotropyUV( anisotropyStrength ) * sqrt( m2 );",

			"#ifdef ANISOTROPYROTATION",
				"mat2 anisotropicRotationMatrix = createRotationMat2( anisotropyRotationStrength * 2.0 * PI );",
    		"#endif",

			"vec3 anisotropicS = tsb[1];",	// binormal in eye space.
			"vec3 anisotropicT = tsb[0];",	// tangent in eye space.

		"#endif",

		"vec3 totalLighting  = vec3( 0.0 );",

		"#if ( defined( USE_ENVMAP ) || defined( USE_DIFFUSEENVMAP ) ) && defined( PHYSICAL )",

			"{",

				"vec3 reflectVec;",

				"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"vec3 worldNormal = vec3( normalize( ( vec4( normal, 0.0 ) * viewMatrix ).xyz ) );",
				"vec3 worldView = -vec3( normalize( ( vec4( viewPosition, 0.0 ) * viewMatrix ).xyz ) );",

					"if ( useRefract ) {",

						// viewPosition may inverted
						"reflectVec = refract( worldView, worldNormal, refractionRatio );",

					"} else { ",

						"reflectVec = reflect( worldView, worldNormal );",

					"}",

				"#else",

					"reflectVec = vReflect;",

				"#endif",

				"vec3 hVector = normal;//normalize( viewPosition.xyz + lVector.xyz );",
				"float nDotH = saturate( dot( normal, normal ) );",
				"float hDotV = saturate( dot( normal, viewPosition ) );",
				"float nDotL = hDotV;//saturate( dot( normal, lVector ) );",


				"vec3 queryVector = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );",

				"#ifdef DOUBLE_SIDED",

					"queryVector *= ( -1.0 + 2.0 * float( gl_FrontFacing ) );",

				"#endif",

				"vec3 worldEnvNormal = vec3( normalize( ( vec4( normal, 0.0 ) * viewMatrix ).xyz ) );",
				"worldEnvNormal = vec3( flipEnvMap * worldEnvNormal.x, worldEnvNormal.yz );",

				"#ifdef DOUBLE_SIDED",

					"worldEnvNormal *= ( -1.0 + 2.0 * float( gl_FrontFacing ) );",

				"#endif",

				// calculate diffuse map contribution

				"vec4 diffuseEnvColor = vec4( 0.0, 0.0, 0.0, 1.0 );",
				"int diffuseEnvColorDecoding = 0;",

				"#if defined( USE_DIFFUSEENVMAP )",

					"diffuseEnvColor = textureCube( diffuseEnvMap, worldEnvNormal );",
					"diffuseEnvColorDecoding = diffuseEnvEncoding;",

				"#elif defined( USE_ENVMAP )",

					"#if defined( TEXTURE_CUBE_LOD_EXT )",

						"diffuseEnvColor = textureCubeLodEXT( envMap, worldEnvNormal, 9.5 );",

					"#endif",

					//	"diffuseEnvColor = textureCube( envMap, worldEnvNormal, 9.5 );",

					//"#endif",

					"diffuseEnvColorDecoding = envEncoding;",

				"#endif",

				// calculate specular map contribution

				"vec4 specularEnvColor = vec4( 0.0, 0.0, 0.0, 1.0 );",
				"int specularEnvColorDecoding = 0;",

				"#if defined( USE_ENVMAP )",

					//"float bias = pow( mix( roughnessStrength, 0.0, pow(1.0 - hDotV, 5.0) ), 0.3 );",

					"#if defined( TEXTURE_CUBE_LOD_EXT )",

						"specularEnvColor = textureCubeLodEXT( envMap, queryVector, roughnessStrength * 9.5 );",

					"#else",

						"specularEnvColor = textureCube( envMap, queryVector ) * ( 0.2 + ( 1.0 - roughnessStrength ) * 0.8 );",

					"#endif",

					"specularEnvColorDecoding = envEncoding;",

				"#endif",

				"diffuseEnvColor = texelDecode( diffuseEnvColor, diffuseEnvColorDecoding );",
				"specularEnvColor = texelDecode( specularEnvColor, specularEnvColorDecoding );",

				"vec3 specClearCoat = vec3(0, 0, 0);",

				"#if defined( CLEARCOAT ) && defined( USE_ENVMAP )",

					//"float biasClearCoat = mix( clearCoatRoughness, 0.0, pow(1.0 - hDotV, 5.0) );",

					"#if defined( TEXTURE_CUBE_LOD_EXT )",

						"vec4 specularClearCoatEnvColor = textureCubeLodEXT( envMap, queryVector, clearCoatRoughness * 9.5 );",

					"#else",

						"vec4 specularClearCoatEnvColor = textureCube( envMap, queryVector ) * ( 0.2 + ( 1.0 - clearCoatRoughness ) * 0.8 );",

					"#endif",

					"specularClearCoatEnvColor = texelDecode( specularClearCoatEnvColor, envEncoding );",

					"vec3 fresnelClearCoat = Fresnel_Schlick_SpecularBlendToWhiteRoughness( vec3( 0.18 ), nDotL, m2ClearCoat );",
					"specClearCoat = specularClearCoatEnvColor.rgb * fresnelClearCoat;",

				"#endif",

				//"float d = 1.0;//Distribution_GGX( m2, nDotH );",

				//"float vis = Visibility_Schlick(m2, nDotL, nDotV);",

			    "vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhiteRoughness( specularColor, nDotL, m2 );",

			    // Put it all together
			    "vec3 spec = fresnelColor * specularEnvColor.rgb;",
			    "vec3 diff = diffuseColor * diffuseEnvColor.rgb;",

			    "vec3 shadingResult = spec + diff;",

			    "#ifdef CLEARCOAT",

					"shadingResult = mix( shadingResult, specClearCoat, clearCoat );",

				"#endif",
							    // diffuse
				"totalLighting  += shadingResult;",

			"}",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

				"float distanceAttenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecayExponent[i] );",

				"vec3 incidentLight = pointLightColor[ i ] * distanceAttenuation;",

				"lVector = normalize( lVector );",

				// diffuse

				"vec3 hVector = normalize( viewPosition.xyz + lVector.xyz );",
				"float nDotH = saturate( dot( normal, hVector ) );",
				"float nDotL = saturate( dot( normal, lVector ) );",
				"float hDotV = saturate( dot( hVector, viewPosition ) );",

				"#ifdef CLEARCOAT",

					"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );",
					"float visClearCoat = Visibility_Kelemen( hDotV );",
					"vec3 fresnelClearCoat = Fresnel_Schlick_SpecularBlendToWhite( vec3( 0.18 ), hDotV );",
					"vec3 specClearCoat = clamp( nDotL * dClearCoat * visClearCoat, 0.0, 10.0 ) * fresnelClearCoat;",

				"#endif",

				"#ifdef ANISOTROPY",

					"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );",

					"#ifdef ANISOTROPYROTATION",
	    				"xyDotH = anisotropicRotationMatrix * xyDotH;",
		    		"#endif",

					"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );",

				"#else",

				    "float d = Distribution_GGX( m2, nDotH );",

				"#endif",

				"float vis = Visibility_Schlick(m2, nDotL, nDotV);",
			    "vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor, hDotV );",

			    // Put it all together
			    "vec3 spec = clamp( nDotL * d * vis, 0.0, 10.0 ) * fresnelColor;",
			    "vec3 diff = nDotL * Diffuse_Lambert() * diffuseColor;",

				"#ifdef TRANSLUCENCY",

				    "diff *= whiteCompliment( translucencyColor.xyz );",

				"#endif",

			    "vec3 shadingResult = spec + diff;",

			    "#ifdef CLEARCOAT",

					"shadingResult = mix( shadingResult, specClearCoat, clearCoat );",

				"#endif",
							    // diffuse
				"totalLighting  += incidentLight * shadingResult;",

				"#ifdef TRANSLUCENCY",

					"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );",

					"float viewNormalTL = mix( 1.0, pow( abs( dot( viewPosition.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );",

					"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

				"float distanceAttenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecayExponent[i] );",

				"vec3 incidentLight = spotLightColor[ i ] * distanceAttenuation;",

				"lVector = normalize( lVector );",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					// diffuse

					"incidentLight *= spotEffect;",

					"vec3 hVector = normalize( viewPosition.xyz + lVector.xyz );",
					"float nDotH = saturate( dot( normal, hVector ) );",
					"float nDotL = saturate( dot( normal, lVector ) );",
					"float hDotV = saturate( dot( hVector, viewPosition ) );",

					"#ifdef CLEARCOAT",

						"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );",
						"float visClearCoat = Visibility_Kelemen( hDotV );",
						"vec3 fresnelClearCoat = Fresnel_Schlick_SpecularBlendToWhite( vec3( 0.18 ), hDotV );",
						"vec3 specClearCoat = clamp( nDotL * dClearCoat * visClearCoat, 0.0, 10.0 ) * fresnelClearCoat;",

					"#endif",

					"#ifdef ANISOTROPY",

						"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );",

						"#ifdef ANISOTROPYROTATION",
		    				"xyDotH = anisotropicRotationMatrix * xyDotH;",
			    		"#endif",

						"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );",

					"#else",

					    "float d = Distribution_GGX( m2, nDotH );",

					"#endif",

					"float vis = Visibility_Schlick(m2, nDotL, nDotV);",
				    "vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor, hDotV );",

		   			// Put it all together
				    "vec3 spec = clamp( nDotL * d * vis, 0.0, 10.0 ) * fresnelColor;",
				    "vec3 diff = nDotL * Diffuse_Lambert() * diffuseColor;",

					"#ifdef TRANSLUCENCY",

					    "diff *= whiteCompliment( translucencyColor.xyz );",

					"#endif",

				    "vec3 shadingResult = spec + diff;",

				    "#ifdef CLEARCOAT",

						"shadingResult = mix( shadingResult, specClearCoat, clearCoat );",

					"#endif",
								    // diffuse
					"totalLighting  += incidentLight * shadingResult;",

					"#ifdef TRANSLUCENCY",

						"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );",

						"float viewNormalTL = mix( 1.0, pow( abs( dot( viewPosition.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );",

						"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;",

					"#endif",

				"}",

			"}",

		"#endif",

		"#if MAX_DIR_LIGHTS > 0",

			"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				"vec3 incidentLight = directionalLightColor[ i ];",

				"vec3 hVector = normalize( viewPosition.xyz + lVector.xyz );",
				"float nDotH = saturate( dot( normal, hVector ) );",
				"float nDotL = saturate( dot( normal, lVector ) );",
				"float hDotV = saturate( dot( hVector, viewPosition ) );",

				"#ifdef CLEARCOAT",

					"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );",
					"float visClearCoat = Visibility_Kelemen( hDotV );",
					"vec3 fresnelClearCoat = Fresnel_Schlick_SpecularBlendToWhite( vec3( 0.18 ), hDotV );",
					"vec3 specClearCoat = clamp( nDotL * dClearCoat * visClearCoat, 0.0, 10.0 ) * fresnelClearCoat;",

				"#endif",

				"#ifdef ANISOTROPY",

					"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );",

					"#ifdef ANISOTROPYROTATION",
	    				"xyDotH = anisotropicRotationMatrix * xyDotH;",
		    		"#endif",

					"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );",

				"#else",

				    "float d = Distribution_GGX( m2, nDotH );",

				"#endif",

				"float vis = Visibility_Schlick(m2, nDotL, nDotV);",
			    "vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor, hDotV );",

	   			// Put it all together
			    "vec3 spec = clamp( nDotL * d * vis, 0.0, 10.0 ) * fresnelColor;",
			    "vec3 diff = nDotL * Diffuse_Lambert() * diffuseColor;",

				"#ifdef TRANSLUCENCY",

				    "diff *= whiteCompliment( translucencyColor.xyz );",

				"#endif",

			    "vec3 shadingResult = spec + diff;",

			    "#ifdef CLEARCOAT",

					"shadingResult = mix( shadingResult, specClearCoat, clearCoat );",

				"#endif",
							    // diffuse
				"totalLighting  += incidentLight * shadingResult;",

				"#ifdef TRANSLUCENCY",

					"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );",

					"float viewNormalTL = mix( 1.0, pow( abs( dot( viewPosition.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );",

					"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				// diffuse

				"float nDotL = dot( normal, lVector );",

				// based on page 325 of Real-Time Rendering., equation (8.43)
				"vec3 hemiColor = ( PI / 2.0 ) * ( ( 1.0 + nDotL ) * hemisphereLightSkyColor[ i ] + ( 1.0 - nDotL ) * hemisphereLightGroundColor[ i ] );",

				"totalLighting += diffuseColor * hemiColor;",

			"}",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"for( int i = 0; i < MAX_AREA_LIGHTS; i ++ ) {",

				"vec3 lPosition = ( viewMatrix * vec4( areaLightPosition[ i ], 1.0 ) ).xyz;",
				//"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

				"vec3 width = areaLightWidth[ i ];",
				"vec3 height = areaLightHeight[ i ];",
				"vec3 up = normalize( ( viewMatrix * vec4( height, 0.0 ) ).xyz );",
				"vec3 right = normalize( ( viewMatrix * vec4( width, 0.0 ) ).xyz );",
				"vec3 pnormal = normalize( cross( right, up ) );",

				"float widthScalar = length( width );",
				"float heightScalar = length( height );",

				//project onto plane and calculate direction from center to the projection.
				"vec3 projection = projectOnPlane( -vViewPosition.xyz, lPosition, pnormal );",  // projection in plane
				"vec3 dir = projection - lPosition;",

				//calculate distance from area:
				"vec2 diagonal = vec2( dot( dir, right ), dot( dir, up ) );",
				"vec2 nearest2D = vec2( clamp( diagonal.x, -widthScalar, widthScalar ), clamp( diagonal.y, -heightScalar, heightScalar ) );",
				"vec3 nearestPointInside = lPosition + ( right *nearest2D.x + up * nearest2D.y );",

				"vec3 lVector = ( nearestPointInside + vViewPosition.xyz );",
				"float distanceAttenuation = calcLightAttenuation( length( lVector ), areaLightDistance[ i ], areaLightDecayExponent[i] );",
				"lVector = normalize( lVector );",

				"vec3 incidentLight = areaLightColor[ i ] * distanceAttenuation * 0.01;", // the 0.01 is the area light intensity scaling.

				"float nDotLDiffuse = saturate( dot( normal, lVector ) );",

		   		"vec3 diff = Diffuse_Lambert() * diffuseColor * widthScalar * heightScalar;",

				"vec3 viewReflection = reflect( viewPosition.xyz, normal );",
				"vec3 reflectionLightPlaneIntersection = linePlaneIntersect( -vViewPosition.xyz, viewReflection, lPosition, pnormal );",

				"float specAngle = dot( viewReflection, pnormal );",

				"if ( specAngle < 0.0 ) {",

					"vec3 dirSpec = reflectionLightPlaneIntersection - lPosition;",
					"vec2 dirSpec2D = vec2( dot( dirSpec, right ), dot( dirSpec, up ) );",
					"vec2 nearestSpec2D = vec2( clamp( dirSpec2D.x, -widthScalar, widthScalar ), clamp( dirSpec2D.y, -heightScalar, heightScalar ) );",
					"lVector = normalize( lPosition + ( right *nearestSpec2D.x + up * nearestSpec2D.y ) + vViewPosition.xyz );",

				"} else { ",

					"lVector = vec3( 0 );",

				"}",

				"vec3 hVector = normalize( viewPosition.xyz + lVector.xyz );",
				"float nDotH = saturate( dot( normal, hVector ) );",
				"float nDotL = saturate( dot( normal, lVector ) );",
				"float hDotV = saturate( dot( hVector, viewPosition ) );",

				"#ifdef CLEARCOAT",

					"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );",
					"float visClearCoat = Visibility_Kelemen( hDotV );",
					"vec3 fresnelClearCoat = Fresnel_Schlick_SpecularBlendToWhite( vec3( 0.18 ), hDotV );",
					"vec3 specClearCoat = clamp( nDotL * dClearCoat * visClearCoat, 0.0, 10.0 ) * fresnelClearCoat;",

				"#endif",

				"#ifdef TRANSLUCENCY",

				    "diff *= whiteCompliment( translucencyColor.xyz );",

				"#endif",

				"#ifdef CLEARCOAT",

					"diff = mix( diff, specClearCoat, clearCoat );",

				"#endif",


				"#ifdef ANISOTROPY",

					"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );",

					"#ifdef ANISOTROPYROTATION",
	    				"xyDotH = anisotropicRotationMatrix * xyDotH;",
		    		"#endif",

					"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );",

				"#else",

				    "float d = Distribution_GGX( m2, nDotH );",

				"#endif",

				"float vis = Visibility_Schlick(m2, nDotL, nDotV);",
			    "vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor, hDotV );",

	   			// Put it all together
			    "vec3 spec = clamp( nDotL * d * vis, 0.0, 10.0 ) * fresnelColor;",

				"totalLighting  += incidentLight * spec;",
				"totalLighting  += incidentLight * nDotLDiffuse * diff;",

				"#ifdef TRANSLUCENCY",

					"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );",

					"float viewNormalTL = mix( 1.0, pow( abs( dot( viewPosition.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );",

					"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;",

				"#endif",

			"}",

		"#endif",

		"#ifdef CLEARCOAT",

			"totalLighting += diffuseColor * ( ambientLightColor * ( 1.0 - clearCoat ) );",

		"#else",

			"totalLighting += diffuseColor * ambientLightColor;",

		"#endif",

		"gl_FragColor.xyz += totalLighting;",

		"vec3 emissiveLocal = emissive;",

		"#ifdef USE_EMISSIVEMAP",

			"vec3 emissiveColor = texture2D( emissiveMap, vUv2 ).xyz;",

			"#ifdef GAMMA_INPUT",

				"emissiveColor *= emissiveColor;",

			"#endif",

			"emissiveLocal *= emissiveColor;",

		"#endif",

		"gl_FragColor.xyz += emissiveLocal;",

		"vec3 ambientLocal = ambient;",

		"#ifdef USE_LIGHTMAP",

			"vec3 ambientColor = texture2D( lightMap, vUv2 ).xyz;",

			"#ifdef GAMMA_INPUT",

				"ambientColor *= ambientColor;",

			"#endif",

			"ambientLocal *= ambientColor;",

			"#ifdef CLEARCOAT",

				"ambientLocal *= ( 1.0 - clearCoat );",

			"#endif",

		"#endif",

		"gl_FragColor.xyz += diffuseColor * ambientLocal;",

	].join("\n"),

	// LIGHTS PHONG

	lights_phong_pars_vertex: [

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )",

			"varying vec3 vWorldPosition;",

		"#endif"

	].join("\n"),


	lights_phong_vertex: [

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )",

			"vWorldPosition = worldPosition.xyz;",

		"#endif"

	].join("\n"),

	lights_phong_pars_fragment: [

		"uniform vec3 ambientLightColor;",

		"#ifndef USE_ENVMAP",

			"uniform float reflectivity;",

		"#endif",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDecayExponent[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDecayExponent[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"uniform vec3 areaLightColor[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightPosition[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightWidth[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightHeight[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDistance[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDecayExponent[ MAX_AREA_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif",

		"varying vec3 vViewPosition;",
		"varying vec3 vNormal;"

	].join("\n"),

	lights_phong_fragment: [

		"vec3 normal = normalize( vNormal );",
		"vec3 viewPosition = normalize( vViewPosition );",

		"#ifdef DOUBLE_SIDED",

			"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",

		"#endif",

		"#ifdef USE_NORMALMAP",

			"normal = perturbNormal2Arb( -vViewPosition, normal );",

		"#elif defined( USE_BUMPMAP )",

			"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"vec3 pointDiffuse  = vec3( 0.0 );",
			"vec3 pointSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

				"float distanceAttenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecayExponent[i] );",

				"lVector = normalize( lVector );",

				// diffuse

				"float dotProduct = dot( normal, lVector );",

				"float pointDiffuseWeight = max( dotProduct, 0.0 );",

				"pointDiffuse  += pointLightColor[ i ] * pointDiffuseWeight * distanceAttenuation;",

				// specular

				"vec3 pointHalfVector = normalize( lVector + viewPosition );",
				"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
				"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );",
				"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * distanceAttenuation * specularNormalization;",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"vec3 spotDiffuse  = vec3( 0.0 );",
			"vec3 spotSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

				"float distanceAttenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecayExponent[i] );",

				"lVector = normalize( lVector );",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					// diffuse

					"float dotProduct = dot( normal, lVector );",

					"#ifdef WRAP_AROUND",

						"float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
						"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

						"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

					"#else",

						"float spotDiffuseWeight = max( dotProduct, 0.0 );",

					"#endif",

					"spotDiffuse += spotLightColor[ i ] * spotDiffuseWeight * distanceAttenuation * spotEffect;",

					// specular

					"vec3 spotHalfVector = normalize( lVector + viewPosition );",
					"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
					"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

					// 2.0 => 2.0001 is hack to work around ANGLE bug

					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );",
					"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * distanceAttenuation * specularNormalization * spotEffect;",

				"}",

			"}",

		"#endif",

		"#if MAX_DIR_LIGHTS > 0",

			"vec3 dirDiffuse  = vec3( 0.0 );",
			"vec3 dirSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
				"vec3 dirVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, dirVector );",

				"#ifdef WRAP_AROUND",

					"float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
					"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

					"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",

				"#else",

					"float dirDiffuseWeight = max( dotProduct, 0.0 );",

				"#endif",

				"dirDiffuse  += directionalLightColor[ i ] * dirDiffuseWeight;",

				// specular

				"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
				"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
				"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				//"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;",

				"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );",
				"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",


			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"vec3 hemiDiffuse  = vec3( 0.0 );",
			"vec3 hemiSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, lVector );",
				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

				"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"hemiDiffuse += hemiColor;",

				// specular (sky light)

				"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
				"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
				"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",

				// specular (ground light)

				"vec3 lVectorGround = -lVector;",

				"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
				"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
				"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",

				"float dotProductGround = dot( normal, lVectorGround );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );",
				"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );",
				"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

			"}",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"vec3 areaDiffuse  = vec3( 0.0 );",
			"vec3 areaSpecular = vec3( 0.0 );",

			"for( int i = 0; i < MAX_AREA_LIGHTS; i ++ ) {",

				"vec3 lPosition = ( viewMatrix * vec4( areaLightPosition[ i ], 1.0 ) ).xyz;",
				//"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

				"vec3 width = areaLightWidth[ i ];",
				"vec3 height = areaLightHeight[ i ];",
				"vec3 up = normalize( ( viewMatrix * vec4( height, 0.0 ) ).xyz );",
				"vec3 right = normalize( ( viewMatrix * vec4( width, 0.0 ) ).xyz );",
				"vec3 pnormal = normalize( cross( right, up ) );",

				"float widthScalar = length( width );",
				"float heightScalar = length( height );",

				//project onto plane and calculate direction from center to the projection.
				"vec3 projection = projectOnPlane( -vViewPosition.xyz, lPosition, pnormal );",  // projection in plane
				"vec3 dir = projection - lPosition;",

				//calculate distance from area:
				"vec2 diagonal = vec2( dot( dir, right ), dot( dir, up ) );",
				"vec2 nearest2D = vec2( clamp( diagonal.x, -widthScalar, widthScalar ), clamp( diagonal.y, -heightScalar, heightScalar ) );",
				"vec3 nearestPointInside = lPosition + ( right *nearest2D.x + up * nearest2D.y );",

				"vec3 lVector = ( nearestPointInside + vViewPosition.xyz );",
				"float distanceAttenuation = calcLightAttenuation( length( lVector ), areaLightDistance[ i ], areaLightDecayExponent[i] );",
				"lVector = normalize( lVector );",

				"float nDotLDiffuse = saturate( dot( normal, lVector ) );",

				"vec3 viewReflection = reflect( viewPosition.xyz, normal );",
				"vec3 reflectionLightPlaneIntersection = linePlaneIntersect( -vViewPosition.xyz, viewReflection, lPosition, pnormal );",

				"float specAngle = dot( viewReflection, pnormal );",

				"if ( specAngle < 0.0 ) {",

					"vec3 dirSpec = reflectionLightPlaneIntersection - lPosition;",
					"vec2 dirSpec2D = vec2( dot( dirSpec, right ), dot( dirSpec, up ) );",
					"vec2 nearestSpec2D = vec2( clamp( dirSpec2D.x, -widthScalar, widthScalar ), clamp( dirSpec2D.y, -heightScalar, heightScalar ) );",
					"lVector = normalize( lPosition + ( right *nearestSpec2D.x + up * nearestSpec2D.y ) + vViewPosition.xyz );",

				"} else { ",

					"lVector = vec3( 0 );",

				"}",

				// diffuse

				"float dotProduct = nDotLDiffuse;",

				"float areaDiffuseWeight = max( dotProduct, 0.0 );",

				"areaDiffuse  += areaLightColor[ i ] * areaDiffuseWeight * distanceAttenuation * widthScalar * heightScalar * 0.01;",  // the 0.01 is the area light intensity scaling.

				// specular

				"vec3 areaHalfVector = normalize( lVector + viewPosition );",
				"float areaDotNormalHalf = max( dot( normal, areaHalfVector ), 0.0 );",
				"float areaSpecularWeight = specularStrength * max( pow( areaDotNormalHalf, shininess ), 0.0 );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, areaHalfVector ), 0.0 ), 5.0 );",
				"areaSpecular += schlick * areaLightColor[ i ] * areaSpecularWeight * areaDiffuseWeight * distanceAttenuation * specularNormalization * 0.01;",  // the 0.01 is the area light intensity scaling.

			"}",

		"#endif",

		"vec3 totalDiffuse = vec3( 0.0 );",
		"vec3 totalSpecular = vec3( 0.0 );",

		"#if MAX_DIR_LIGHTS > 0",

			"totalDiffuse += dirDiffuse;",
			"totalSpecular += dirSpecular;",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"totalDiffuse += hemiDiffuse;",
			"totalSpecular += hemiSpecular;",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"totalDiffuse += pointDiffuse;",
			"totalSpecular += pointSpecular;",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"totalDiffuse += spotDiffuse;",
			"totalSpecular += spotSpecular;",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"totalDiffuse += areaDiffuse;",
			"totalSpecular += areaSpecular;",

		"#endif",
		"vec3 ambientLocal = ambient;",

		"#ifdef USE_LIGHTMAP",

			"vec3 ambientColor = texture2D( lightMap, vUv2 ).xyz;",

			"#ifdef GAMMA_INPUT",

				"ambientColor *= ambientColor;",

			"#endif",

			"ambientLocal *= ambientColor;",

		"#endif",

		"gl_FragColor.xyz = diffuseColor * ( totalDiffuse + ambientLightColor + ambientLocal ) + totalSpecular;",

		"vec3 emissiveLocal = emissive;",

		"#ifdef USE_EMISSIVEMAP",

			"vec3 emissiveColor = texture2D( emissiveMap, vUv2 ).xyz;",

			"#ifdef GAMMA_INPUT",

				"emissiveColor *= emissiveColor;",

			"#endif",

			"emissiveLocal *= emissiveColor;",

		"#endif",

		"gl_FragColor.xyz += emissiveLocal.xyz;",

	].join("\n"),

	// VERTEX COLORS

	color_pars_fragment: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_fragment: [

		"#ifdef USE_COLOR",

			"gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );",

		"#endif"

	].join("\n"),

	color_pars_vertex: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_vertex: [

		"#ifdef USE_COLOR",

			"#ifdef GAMMA_INPUT",

				"vColor = color * color;",

			"#else",

				"vColor = color;",

			"#endif",

		"#endif"

	].join("\n"),

	// SKINNING

	skinning_pars_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef BONE_TEXTURE",

				"uniform sampler2D boneTexture;",
				"uniform int boneTextureWidth;",
				"uniform int boneTextureHeight;",

				"mat4 getBoneMatrix( const in float i ) {",

					"float j = i * 4.0;",
					"float x = mod( j, float( boneTextureWidth ) );",
					"float y = floor( j / float( boneTextureWidth ) );",

					"float dx = 1.0 / float( boneTextureWidth );",
					"float dy = 1.0 / float( boneTextureHeight );",

					"y = dy * ( y + 0.5 );",

					"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
					"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
					"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
					"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",

					"mat4 bone = mat4( v1, v2, v3, v4 );",

					"return bone;",

				"}",

			"#else",

				"uniform mat4 boneGlobalMatrices[ MAX_BONES ];",

				"mat4 getBoneMatrix( const in float i ) {",

					"mat4 bone = boneGlobalMatrices[ int(i) ];",
					"return bone;",

				"}",

			"#endif",

		"#endif"

	].join("\n"),

	skinbase_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 boneMatX = getBoneMatrix( skinIndex.x );",
			"mat4 boneMatY = getBoneMatrix( skinIndex.y );",
			"mat4 boneMatZ = getBoneMatrix( skinIndex.z );",
			"mat4 boneMatW = getBoneMatrix( skinIndex.w );",

		"#endif"

	].join("\n"),

	skinning_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef USE_MORPHTARGETS",

			"vec4 skinVertex = vec4( morphed, 1.0 );",

			"#else",

			"vec4 skinVertex = vec4( position, 1.0 );",

			"#endif",

			"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
			"skinned      += boneMatY * skinVertex * skinWeight.y;",
			"skinned      += boneMatZ * skinVertex * skinWeight.z;",
			"skinned      += boneMatW * skinVertex * skinWeight.w;",

		"#endif"

	].join("\n"),

	// MORPHING

	morphtarget_pars_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"#ifndef USE_MORPHNORMALS",

			"uniform float morphTargetInfluences[ 8 ];",

			"#else",

			"uniform float morphTargetInfluences[ 4 ];",

			"#endif",

		"#endif"

	].join("\n"),

	morphtarget_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"vec3 morphed = vec3( 0.0 );",
			"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
			"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
			"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
			"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",

			"#ifndef USE_MORPHNORMALS",

			"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
			"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
			"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
			"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",

			"#endif",

			"morphed += position;",

		"#endif"

	].join("\n"),

	default_vertex : [

		"vec4 mvPosition;",

		"#ifdef USE_SKINNING",

			"mvPosition = modelViewMatrix * skinned;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( position, 1.0 );",

		"#endif",

		"gl_Position = projectionMatrix * mvPosition;"

	].join("\n"),

	morphnormal_vertex: [

		"#ifdef USE_MORPHNORMALS",

			"vec3 morphedNormal = vec3( 0.0 );",

			"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
			"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
			"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
			"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",

			"morphedNormal += normal;",

		"#endif"

	].join("\n"),

	skinnormal_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 skinMatrix = skinWeight.x * boneMatX;",
			"skinMatrix 	+= skinWeight.y * boneMatY;",

			"#ifdef USE_MORPHNORMALS",

			"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );",

			"#else",

			"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	defaultnormal_vertex: [

		"vec3 objectNormal;",

		"#ifdef USE_SKINNING",

			"objectNormal = skinnedNormal.xyz;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )",

			"objectNormal = morphedNormal;",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )",

			"objectNormal = normal;",

		"#endif",

		"#ifdef FLIP_SIDED",

			"objectNormal = -objectNormal;",

		"#endif",

		"vec3 transformedNormal = normalMatrix * objectNormal;"

	].join("\n"),

	// SHADOW MAP

	// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples
	//  http://spidergl.org/example.php?id=6
	// 	http://fabiensanglard.net/shadowmapping

	shadowmap_pars_fragment: [

		"#ifdef USE_SHADOWMAP",

			"uniform sampler2D shadowMap[ MAX_SHADOWS ];",
			"uniform vec2 shadowMapSize[ MAX_SHADOWS ];",

			"uniform float shadowDarkness[ MAX_SHADOWS ];",
			"uniform float shadowBias[ MAX_SHADOWS ];",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",

			"float unpackDepth( const in vec4 rgba_depth ) {",

				"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
				"float depth = dot( rgba_depth, bit_shift );",
				"return depth;",

			"}",

		"#endif"

	].join("\n"),

	shadowmap_fragment: [

		"#ifdef USE_SHADOWMAP",

			"#ifdef SHADOWMAP_DEBUG",

				"vec3 frustumColors[3];",
				"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );",
				"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );",
				"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );",

			"#endif",

			"#ifdef SHADOWMAP_CASCADE",

				"int inFrustumCount = 0;",

			"#endif",

			"float fDepth;",
			"vec3 shadowColor = vec3( 1.0 );",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",

				// "if ( something && something )" 		 breaks ATI OpenGL shader compiler
				// "if ( all( something, something ) )"  using this instead

				"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
				"bool inFrustum = all( inFrustumVec );",

				// don't shadow pixels outside of light frustum
				// use just first frustum (for cascades)
				// don't shadow pixels behind far plane of light frustum

				"#ifdef SHADOWMAP_CASCADE",

					"inFrustumCount += int( inFrustum );",
					"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );",

				"#else",

					"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",

				"#endif",

				"bool frustumTest = all( frustumTestVec );",

				"if ( frustumTest ) {",

					"shadowCoord.z += shadowBias[ i ];",

					"#if defined( SHADOWMAP_TYPE_PCF )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						/*
						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL
						// must enroll loop manually

						"for ( float y = -1.25; y <= 1.25; y += 1.25 )",
							"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {",

								"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );",

								// doesn't seem to produce any noticeable visual difference compared to simple "texture2D" lookup
								//"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );",

								"float fDepth = unpackDepth( rgbaDepth );",

								"if ( fDepth < shadowCoord.z )",
									"shadow += 1.0;",

						"}",

						"shadow /= 9.0;",

						*/

						"const float shadowDelta = 1.0 / 9.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.25 * xPixelOffset;",
						"float dy0 = -1.25 * yPixelOffset;",
						"float dx1 = 1.25 * xPixelOffset;",
						"float dy1 = 1.25 * yPixelOffset;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.0 * xPixelOffset;",
						"float dy0 = -1.0 * yPixelOffset;",
						"float dx1 = 1.0 * xPixelOffset;",
						"float dy1 = 1.0 * yPixelOffset;",

						"mat3 shadowKernel;",
						"mat3 depthKernel;",

						"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",

						"vec3 shadowZ = vec3( shadowCoord.z );",
						"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));",
						"shadowKernel[0] *= vec3(0.25);",

						"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));",
						"shadowKernel[1] *= vec3(0.25);",

						"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));",
						"shadowKernel[2] *= vec3(0.25);",

						"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );",

						"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
						"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",

						"vec4 shadowValues;",
						"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
						"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
						"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
						"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",

						"shadow = dot( shadowValues, vec4( 1.0 ) );",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#else",

						"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
						"float fDepth = unpackDepth( rgbaDepth );",

						"if ( fDepth < shadowCoord.z )",

							// spot with multiple shadows is darker

							"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );",

							// spot with multiple shadows has the same color as single shadow spot

							//"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );",

					"#endif",

				"}",


				"#ifdef SHADOWMAP_DEBUG",

					"#ifdef SHADOWMAP_CASCADE",

						"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#else",

						"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#endif",

				"#endif",

			"}",

			"#ifdef GAMMA_OUTPUT",

				"shadowColor *= shadowColor;",

			"#endif",

			"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;",

		"#endif"

	].join("\n"),

	shadowmap_pars_vertex: [

		"#ifdef USE_SHADOWMAP",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",
			"uniform mat4 shadowMatrix[ MAX_SHADOWS ];",

		"#endif"

	].join("\n"),

	shadowmap_vertex: [

		"#ifdef USE_SHADOWMAP",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

			"}",

		"#endif"

	].join("\n"),

	// ALPHATEST

	alphatest_fragment: [

		"#ifdef ALPHATEST",

			"if ( gl_FragColor.a < ALPHATEST ) discard;",

		"#endif"

	].join("\n"),

	// LINEAR SPACE

	linear_to_gamma_fragment: [

		"#ifdef GAMMA_OUTPUT",

			"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",

		"#endif"

	].join("\n")


};