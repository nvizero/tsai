/**
 *
 * @author bhouston / http://clara.io/
 *
 */

THREE.MeshPhysicalMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.map = null;
	this.opacityMap = null;

	this.falloff = false;
	this.falloffColor = new THREE.Color( 0xffffff );
	this.falloffMap = null;
	this.falloffBlendParams = new THREE.Vector4( 1.0, 0.0, 0.0, 1.0 );

	this.specular = new THREE.Color( 0xffffff );
	this.specularMap = null;

	this.roughness = 0.5;
	this.roughnessMap = null;

	this.metallic = 0.0;
	this.metallicMap = null;

	this.clearCoat = 0.0;	// 0 means no clear coat, 1 means complete clear coat.
	this.clearCoatRoughness = 0.2;

	this.anisotropy = 0.0;	// valid range is [-1,1].-1 is max vertical elongation, 0 is normal, +1 is max horizontal elongation
	this.anisotropyMap = null;	// only R is read and considered to be anisotropy.  To get negative values, use texture brightness, gain
	this.anisotropyRotation = 0.0; // converted to radias via multiplication by 2*PI.  Thus the range [ 0 - 1 ] maps to radian [0, PI].
	this.anisotropyRotationMap = null;  // only R is read and considered to be anisotropyRotation.

	this.translucency = new THREE.Color( 0x000000 );
	this.translucencyMap = null;
	this.translucencyNormalAlpha = 0.75;
	this.translucencyNormalPower = 1.0;
	this.translucencyViewPower = 2.0;
	this.translucencyViewAlpha = 0.75;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.emissive = new THREE.Color( 0x000000 );
	this.emissiveMap = null; 	// given off arbitrarily by the object in all directions.  Basically GI.

	this.ambient = new THREE.Color( 0x000000 );
	this.lightMap = null; // incoming light

	this.envMap = null;  // Incoming environmental light.
	this.diffuseEnvMap = null;  // irradiance light.

	this.combine = THREE.AddOperation;

	this.shading = THREE.SmoothShading

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.blending = THREE.CustomBlending;
	this.blendSrc = THREE.OneFactor;	// output of shader must be premultiplied
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );
};

THREE.MeshPhysicalMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshPhysicalMaterial.prototype.clone = function () {

	var material = new THREE.MeshPhysicalMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.map = this.map;
	material.opacityMap = this.opacityMap;

	material.falloff = this.falloff;
	material.falloffColor.copy( this.falloffColor );
	material.falloffMap = this.falloffMap;
	material.falloffBlendParams.copy( this.falloffBlendParams );

	material.specular.copy( this.specular );
	material.specularMap = this.specularMap;

	material.roughness = this.roughness;
	material.roughnessMap = this.roughnessMap;
	material.metallic = this.metallic;
	material.metallicMap = this.metallicMap;

	material.shading = this.shading;

	material.translucency.copy( this.translucency );
	material.translucencyMap = this.translucencyMap;
	material.translucencyNormalAlpha = this.translucencyNormalAlpha;
	material.translucencyNormalPower = this.translucencyNormalPower;
	material.translucencyViewPower = this.translucencyViewPower;
	material.translucencyViewAlpha = this.translucencyViewAlpha;

	material.bumpMap = this.bumpMap;
	material.bumpScale = this.bumpScale;

	material.normalMap = this.normalMap;
	material.normalScale.copy( this.normalScale );

	material.emissive.copy( this.emissive );
	material.emissiveMap = this.emissiveMap;

	material.ambient.copy( this.ambient );
	material.lightMap = this.lightMap;

	material.envMap = this.envMap;
	material.diffuseEnvMap = this.diffuseEnvMap;

	material.combine = this.combine;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};
